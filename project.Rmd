---
title: Analiza skupa podataka o kvalitetu voda
date: "`r format(Sys.time(), '%d. %B %Y')`"
author: Stefan Aleksić
output: html_document
---

# Uvod

U ovom izveštaju su predstavljeni rezultati kreiranja modela za analizu kvaliteta voda u okviru država Evrope.

## Skup podataka **voda**

Skup podataka o vodama je privučen sa sajta [eea.europa.eu](https://www.eea.europa.eu/data-and-maps/data/waterbase-water-quality-icm-2). Uz pomoć naredbi

```{bash download data, eval=F, include=T}
curl -X GET  --header 'Content-Type: application/json' --header 'Accept: application/zip' https://cmshare.eea.europa.eu/s/B8dr3zPX6cyswpX/download --output data.zip

unzip data.zip /home/stefan/rvpuii-project/workspace/data
```


# Rad

### Inicijalizacija

#### Prevlačenje paketa i instaliranje spark-a
```{r downloading packages, eval=F, include=T}
install.packages("sparklyr")
install.packages("tidyverse")
install.packages("gridExtra")
```


#### Uključivanje neophodnih biblioteka
```{r library setup, eval=F, include=T}
library(tidyr)
library(dplyr)
library(ggplot2)
library(magrittr)
library(knitr)
library(sparklyr)
library(cowplot)
```


#### Instaliranje i povezivanje sa spark-om
```{r spark setup, eval=F, include=T}
spark_install(version="3.3.2")
Sys.setenv(JAVA_HOME="/usr/lib/jvm/java-1.11.0-openjdk-amd64")
knitr::opts_knit$set(root.dir = "/home/stefan/rvpuii-project/workspace")
sc <- spark_connect(master = "local", version="3.3.2")
```


#### Učitavanje podataka
```{r loading dataset, eval=F, include=T}
vode <- spark_read_csv(sc,
                         name="water",
                         path = "/home/stefan/rvpuii-project/workspace/data/",
                         memory = T)
```


#### Prečišćavanje podataka
```{r mutating dataset, eval=F, include=T}
vode.filtered <- vode %>%
  filter(!(is.na(resultQualityMeanBelowLOQ) ||
           is.na(observedPropertyDeterminandCode) ||
           is.na(resultNumberOfSamples) ||
           is.na(parameterWaterBodyCategory) ||
           is.na(resultStandardDeviationValue))) %>%
  mutate(quantified = ifelse(resultQualityMeanBelowLOQ > 0, 0, 1)) %>%
  select(c(quantified, parameterWaterBodyCategory, observedPropertyDeterminandCode, resultNumberOfSamples, resultStandardDeviationValue))
```


##### Dimenzije pre i posle prečišćavanja
```{r Dimenzije pre i posle prečišćavanja, inlcude=T, echo=F, eval=T}
sdf_dim(vode)
sdf_dim(vode.filtered)
```


### Treniranje modela logističke regresije sa različitim vrednostima broja maksimalnih iteracija
```{r splitting data to training and testing datasets, eval=F, include=T}
dataset <- sdf_random_split(vode.filtered, seed=1, training=0.8, test=0.2)
formula <- quantified ~ parameterWaterBodyCategory + resultNumberOfSamples + resultStandardDeviationValue

samples <- c(1:5)
max.iterations <- samples * 5
log.reg.weighted.precision <- samples
log.reg.weighted.recall <- samples
log.reg.weighted.f.measure <- samples
log.reg.area.under.roc <- samples
log.reg.accuracy <- samples

for(i in samples){
  logreg <- ml_logistic_regression(dataset$training,
                                   formula,
                                   max_iter = max.iterations[i],
                                   family = "binomial")
    evaluation <- ml_evaluate(logreg, dataset=dataset$test)
    log.reg.weighted.precision[i] <- evaluation$weighted_precision()
    log.reg.weighted.recall[i] <- evaluation$weighted_recall()
    log.reg.weighted.f.measure[i] <- evaluation$weighted_f_measure()
    log.reg.area.under.roc[i] <- evaluation$area_under_roc()
    log.reg.accuracy[i] <- evaluation$accuracy()
}
```


#### Prikaz zavisnosti broja iteracija od tačnosti modela
```{r graphing, include=T}
df <- data.frame(i=max.iterations,
                 wp=log.reg.weighted.precision,
                 wr=log.reg.weighted.recall,
                 wf=log.reg.weighted.f.measure,
                 aur=log.reg.area.under.roc,
                 a=log.reg.accuracy)
p1 <- df %>%
ggplot(aes(i, wp)) +
  geom_line() +
  scale_x_continuous(breaks=max.iterations) +
  scale_y_continuous(breaks=log.reg.weighted.precision) +
  labs(x="Broj iteracija", y="Preciznost")

p2 <- df %>%
ggplot(aes(i, wr)) +
  geom_line() +
  scale_x_continuous(breaks=max.iterations) +
  scale_y_continuous(breaks=log.reg.weighted.recall) +
  labs(x="Broj iteracija", y="Osetljivost")

p3 <- df %>%
  ggplot(aes(i, wf)) +
  geom_line() +
  scale_x_continuous(breaks=max.iterations) +
  scale_y_continuous(breaks=log.reg.weighted.f.measure) +
  labs(x="Broj iteracija", y="F1")

p4 <- df %>%
  ggplot(aes(i, aur)) +
  geom_line() +
  scale_x_continuous(breaks=max.iterations) +
  scale_y_continuous(breaks=log.reg.area.under.roc) +
  labs(x="Broj iteracija", y="Površina ispod ROC krive")

plot_grid(p1, p2, p3, p4, nrow=2, ncol=2)

df %>%
  ggplot(aes(i, a)) +
  geom_line() +
  scale_x_continuous(breaks=max.iterations) +
  scale_y_continuous(breaks=log.reg.accuracy) +
  labs(x="Broj iteracija", y="Tačnost")
```

### Tačnost različitih klasifikacionih modela u odnosu na metod testiranja modela
```{r Kreiranje tri različita klasifikaciona modela, eval=F, include=T}

formula <- quantified ~ parameterWaterBodyCategory + resultNumberOfSamples + resultStandardDeviationValue

# Validacioni skup
dataset <- sdf_random_split(vode.filtered, seed=1, training=0.8, test=0.2)

bayes.model <- dataset$training %>% 
  ml_naive_bayes(formula)

linear.svc.model <- dataset$training %>%
  ml_linear_svc(formula)

decision.tree.classifier <- dataset$training %>%
  ml_decision_tree_classifier(formula)

bm.vs.accuracy <- ml_evaluate(bayesov.model, dataset$test)$Accuracy
svcm.vs.accuracy <- ml_evaluate(linear.svc.model, dataset$test)$Accuracy
d3m.vs.accuracy <- ml_evaluate(decision.tree.classifier, dataset$test)$Accuracy

# 4-trostruko ukrstanje
k.cross.fold.4 <- function(filtered.dataset, model, formula){
  dataset <- filtered.dataset %>%
    sdf_random_split(seed=1,
                     s1=0.25,
                     s2=0.25,
                     s3=0.25,
                     s4=0.25)
  training <- list(
    s1 = sdf_bind_rows(dataset$s2, dataset$s3, dataset$s4),
    s2 = sdf_bind_rows(dataset$s1, dataset$s3, dataset$s4),
    s3 = sdf_bind_rows(dataset$s1, dataset$s2, dataset$s4),
    s4 = sdf_bind_rows(dataset$s1, dataset$s2, dataset$s3)
  )
  
  trained = list(s1=model(training$s1, formula),
                 s2=model(training$s2, formula),
                 s3=model(training$s3, formula),
                 s4=model(training$s4, formula)
  )
  
  model.accuracy <- (ml_evaluate(trained$s1, dataset$s1)$Accuracy +
                       ml_evaluate(trained$s2, dataset$s2)$Accuracy +
                       ml_evaluate(trained$s3, dataset$s3)$Accuracy +
                       ml_evaluate(trained$s4, dataset$s4)$Accuracy
  ) / 4
}

bayes.model.4.fold.accuracy <- k.cross.fold.4(vode.filtered, ml_naive_bayes, formula)
svc.4.fold.accuracy <- k.cross.fold.4(vode.filtered, ml_linear_svc, formula)
d3.4.fold.accuracy <- k.cross.fold.4(vode.filtered, ml_decision_tree_classifier, formula)
```

#### Tabelarni prikaz tačnosti različitih klasifikacionih modela u odnosu na metod testiranja modela
```{r Tabelarni prikaz rezultata, echo=F}
knitr::kable(array(c("Bayes-ov model", "Mašina potpornih vektora", "Stablo odlučivanja",
                     bm.vs.accuracy, svcm.vs.accuracy, d3m.vs.accuracy,
                     bayes.model.4.fold.accuracy, svc.4.fold.accuracy, d3.4.fold.accuracy),
                   dim = c(3,3)),
             col.names = c("Model", "Preciznost korišćenjem validacionog skupa", "Preciznost korišćenjem 4-strukog ukrštanja"),
             label = "Poređenje tačnosti različitih klasifikacionih modela u odnosu na načine validacije",
             align = "ccc",
             format = "markdown"
             )
```


## Klasterizacija podataka

### Prečišćenih podataka za klasterizaciju
```{r Prečišćavanje podataka za klasterizaciju, eval=F, include=T}
dataset <- vode.filtered %>%
  mutate(parameterWaterBodyCategory = switch(parameterWaterBodyCategory,
                                             CW="Coastal water body",
                                             GW="Groundwater body",
                                             LW="Lake water body",
                                             MW="Marine waters",
                                             RW="River water body",
                                             TW="Transitional water body",
                                             TeW="Territorial waters")) %>%
  select(parameterWaterBodyCategory, resultNumberOfSamples, quantified)

dataset.summary <- dataset %>% 
  group_by(parameterWaterBodyCategory) %>% 
  summarize(count = n(), meanNumberOfSamples = mean(resultNumberOfSamples), stdev = sd(resultNumberOfSamples), quantified = avg(quantified)) %>% collect
```


### Prikaz prečišćenih podataka
```{r}
ggplot(dataset.summary, aes(quantified, meanNumberOfSamples, color = parameterWaterBodyCategory)) +
  geom_errorbar(aes(ymin = meanNumberOfSamples - stdev, ymax = meanNumberOfSamples + stdev), width=0.01) +
  theme(legend.position="right") +
  labs(y="mean(result number of samples)", x="quantified")
```

### Metod k-means
```{r Primena klasterizacionog metoda K-means, eval=F, include=T}
formula.clusterisation <- parameterWaterBodyCategory ~ resultNumberOfSamples + quantified

model.5   <- ml_kmeans(dataset, formula.clusterisation, seed = 1, k = 5)
model.10  <- ml_kmeans(dataset, formula.clusterisation, seed = 1, k = 10)
model.15  <- ml_kmeans(dataset, formula.clusterisation, seed = 1, k = 15)
model.20  <- ml_kmeans(dataset, formula.clusterisation, seed = 1, k = 20)
```

## Prikaz centara klastera u odnosu na broj klastera K
```{r}
cp1 <- model.5$centers %>%
  ggplot(aes(quantified, resultNumberOfSamples)) +
  geom_point() +
  labs(x="quantified", y="resultNumberOfSamples") +
  theme_light()

cp2 <- model.10$centers %>%
  ggplot(aes(quantified, resultNumberOfSamples)) +
  geom_point() +
  labs(x="quantified", y="resultNumberOfSamples") +
  theme_light()

cp3 <- model.15$centers %>%
  ggplot(aes(quantified, resultNumberOfSamples)) +
  geom_point() +
  labs(x="quantified", y="resultNumberOfSamples") +
  theme_light()

cp4 <-  model.20$centers %>%
  ggplot(aes(quantified, resultNumberOfSamples)) +
  geom_point() +
  labs(x="quantified", y="resultNumberOfSamples") +
  theme_light()

plot_grid(cp1, cp2, cp3, cp4, nrow=2, ncol=2)

```


## Zatvaranje spark konekcije
```{r closing spark context, eval=F, include=T}
spark_disconnect(sc)
```

# Zaključak

# Literatura
