---
title: Analiza skupa podataka o kvalitetu voda
date: "`r format(Sys.time(), '%d. %B %Y')`"
author: Stefan Aleksić
output: html_document
---

# Uvod

U ovom izveštaju su predstavljeni rezultati kreiranja modela za analizu kvaliteta voda u okviru država Evrope.

## Skup podataka **voda**

Skup podataka o vodama je privučen sa sajta [eea.europa.eu](https://www.eea.europa.eu/data-and-maps/data/waterbase-water-quality-icm-2). Uz pomoć naredbi

```{bash download data, eval=F, include=T}
curl -X GET  --header 'Content-Type: application/json' --header 'Accept: application/zip' https://cmshare.eea.europa.eu/s/B8dr3zPX6cyswpX/download --output data.zip

unzip data.zip /home/stefan/rvpuii-project/workspace/data
```

Ovaj skup podataka sadrži vremenske serije hranljivih materija, organske materije, opasnih materija i drugih hemikalija u rekama, jezerima, podzemnim vodama, prelaznim, priobalnim i morskim vodama. Lista identifikatora prostornih objekata sa izabranim atributima, o kojima se izveštava preko WFD (The Water Framework Directive) and [WISE Spatial data](http://dd.eionet.europa.eu/datasets/latest/WISE_SpatialData), izveštavač o prostornim podacima, dodaje se skupu podataka kao prostorna [referenca](http://dd.eionet.europa.eu/vocabulary/wise/WFDWaterBodyCategory/). Podatke je sastavila i obradila [EEA (European Environment Agency)](https://www.eea.europa.eu/). Za dodatne informacije pogledajte [metapodatke](https://docs.google.com/spreadsheets/d/1Vv_Wofjg170YPPIZKX1BCxpUb17gvs8QH5vTIoRhOdg/edit?usp=sharing).



# Rad

### Inicijalizacija

#### Prevlačenje neophodnih paketa za analizu podataka
```{r Downloading necessary packages for data analysis, eval=F, include=T}
install.packages("sparklyr")
install.packages("tidyverse")
install.packages("gridExtra")
```


#### Uključivanje neophodnih biblioteka
```{r Loading necessary libraries, eval=F, include=T}
library(tidyr)
library(dplyr)
library(ggplot2)
library(magrittr)
library(knitr)
library(sparklyr)
library(cowplot)
```


#### Instaliranje i pripremanje spark okruženja
```{r Installing and setting up spark environment, eval=F, include=T}
spark_install(version="3.3.2")
Sys.setenv(JAVA_HOME="/usr/lib/jvm/java-1.11.0-openjdk-amd64")
knitr::opts_knit$set(root.dir = "/home/stefan/rvpuii-project/workspace")
sc <- spark_connect(master = "local", version="3.3.2")
```


#### Učitavanje skupa podataka
```{r Loading dataset and its definition, eval=F, include=T}
water.dataset <- spark_read_csv(sc,
                                name="waterdataset",
                                path = "/home/stefan/rvpuii-project/workspace/data/Waterbase_v2021_1_T_WISE6_AggregatedData.csv",
                                memory = T)
```


#### Prečišćavanje podataka
```{r mutating dataset, eval=F, include=T}
water.dataset.filtered <- water.dataset %>%
  filter(!(is.na(resultQualityMeanBelowLOQ) ||
           is.na(observedPropertyDeterminandCode) ||
           is.na(resultNumberOfSamples) ||
           is.na(parameterWaterBodyCategory) ||
           is.na(resultStandardDeviationValue))) %>%
  mutate(quantified = ifelse(resultQualityMeanBelowLOQ > 0, 0, 1)) %>%
  select(quantified,
         parameterWaterBodyCategory,
         observedPropertyDeterminandCode,
         resultNumberOfSamples,
         resultStandardDeviationValue)
```


##### Dimenzije skupa podataka
```{r Dimenzije pre i posle prečišćavanja, inlcude=F, echo=F, eval=T}
sprintf("Dimenzije učitanog skupa podataka:   %d x %d", sdf_nrow(water.dataset), sdf_ncol(water.dataset))
sprintf("Dimenzije prečišćenog skupa podataka: %d x %d", sdf_nrow(water.dataset.filtered), sdf_ncol(water.dataset.filtered))
```


#### Prikaz prvih 10 redova prečišćenih podataka
```{r Displaying first 10 rows of transformed dataset, echo=F}
knitr::kable(head(water.dataset.filtered, n=10L),
             col.names = colnames(water.dataset.filtered),
             label = "Tabelarni prikaz prečišćenih podataka",
             format = "markdown",
             align = "ccccc"
             )
```


### Treniranje modela logističke regresije sa različitim vrednostima broja maksimalnih iteracija
```{r Splitting dataset into training and testing datasets, eval=F, include=T}
dataset.for.clustering <- sdf_random_split(water.dataset.filtered, seed=1, training=0.8, test=0.2)
formula <- quantified ~ parameterWaterBodyCategory + resultNumberOfSamples + resultStandardDeviationValue

samples <- c(1:5)
max.iterations <- samples * 5
log.reg.weighted.precision <- samples
log.reg.weighted.recall <- samples
log.reg.weighted.f.measure <- samples
log.reg.area.under.roc <- samples
log.reg.accuracy <- samples

for(i in samples){
  logreg <- ml_logistic_regression(dataset.for.clustering$training,
                                   formula,
                                   max_iter = max.iterations[i],
                                   family = "binomial")
    evaluation <- ml_evaluate(logreg, dataset=dataset.for.clustering$test)
    log.reg.weighted.precision[i] <- evaluation$weighted_precision()
    log.reg.weighted.recall[i] <- evaluation$weighted_recall()
    log.reg.weighted.f.measure[i] <- evaluation$weighted_f_measure()
    log.reg.area.under.roc[i] <- evaluation$area_under_roc()
    log.reg.accuracy[i] <- evaluation$accuracy()
}
```


#### Prikaz zavisnosti broja iteracija od tačnosti modela
```{r Graphing the dependancy of clustering model accuracy based on the number of maximal iterations, include=T, echo=F}
df <- data.frame(i=max.iterations,
                 wp=log.reg.weighted.precision,
                 wr=log.reg.weighted.recall,
                 wf=log.reg.weighted.f.measure,
                 aur=log.reg.area.under.roc,
                 a=log.reg.accuracy)
p1 <- df %>%
ggplot(aes(i, wp)) +
  geom_line() +
  scale_x_continuous(breaks=max.iterations) +
  scale_y_continuous(breaks=log.reg.weighted.precision) +
  labs(x="Broj iteracija", y="Preciznost")

p2 <- df %>%
ggplot(aes(i, wr)) +
  geom_line() +
  scale_x_continuous(breaks=max.iterations) +
  scale_y_continuous(breaks=log.reg.weighted.recall) +
  labs(x="Broj iteracija", y="Osetljivost")

p3 <- df %>%
  ggplot(aes(i, wf)) +
  geom_line() +
  scale_x_continuous(breaks=max.iterations) +
  scale_y_continuous(breaks=log.reg.weighted.f.measure) +
  labs(x="Broj iteracija", y="F1")

p4 <- df %>%
  ggplot(aes(i, aur)) +
  geom_line() +
  scale_x_continuous(breaks=max.iterations) +
  scale_y_continuous(breaks=log.reg.area.under.roc) +
  labs(x="Broj iteracija", y="Površina ispod ROC krive")

plot_grid(p1, p2, p3, p4, nrow=2, ncol=2)

df %>%
  ggplot(aes(i, a)) +
  geom_line() +
  scale_x_continuous(breaks=max.iterations) +
  scale_y_continuous(breaks=log.reg.accuracy) +
  labs(x="Broj iteracija", y="Tačnost")
```

### Tačnost različitih klasifikacionih modela u odnosu na metod testiranja modela
```{r Comparing the performance of different clustering models using different testing methods, eval=F, include=T}

formula <- quantified ~ parameterWaterBodyCategory + resultNumberOfSamples + resultStandardDeviationValue

# Validacioni skup
dataset.for.validation <- sdf_random_split(water.dataset.filtered, seed=1, training=0.8, test=0.2)

bayes.model <- dataset.for.validation$training %>% 
  ml_naive_bayes(formula)

linear.svc.model <- dataset.for.validation$training %>%
  ml_linear_svc(formula)

decision.tree.classifier <- dataset.for.validation$training %>%
  ml_decision_tree_classifier(formula)

bm.vs.accuracy <- ml_evaluate(bayes.model, dataset.for.validation$test)$Accuracy
svcm.vs.accuracy <- ml_evaluate(linear.svc.model, dataset.for.validation$test)$Accuracy
d3m.vs.accuracy <- ml_evaluate(decision.tree.classifier, dataset.for.validation$test)$Accuracy

# 4-trostruko ukrstanje
k.cross.fold.4 <- function(filtered.dataset, model, formula){
  dataset <- filtered.dataset %>%
    sdf_random_split(seed=1,
                     s1=0.25,
                     s2=0.25,
                     s3=0.25,
                     s4=0.25)
  training <- list(
    s1 = sdf_bind_rows(dataset$s2, dataset$s3, dataset$s4),
    s2 = sdf_bind_rows(dataset$s1, dataset$s3, dataset$s4),
    s3 = sdf_bind_rows(dataset$s1, dataset$s2, dataset$s4),
    s4 = sdf_bind_rows(dataset$s1, dataset$s2, dataset$s3)
  )
  
  trained = list(s1=model(training$s1, formula),
                 s2=model(training$s2, formula),
                 s3=model(training$s3, formula),
                 s4=model(training$s4, formula)
  )
  
  model.accuracy <- (ml_evaluate(trained$s1, dataset$s1)$Accuracy +
                       ml_evaluate(trained$s2, dataset$s2)$Accuracy +
                       ml_evaluate(trained$s3, dataset$s3)$Accuracy +
                       ml_evaluate(trained$s4, dataset$s4)$Accuracy
  ) / 4
}

bayes.model.4.fold.accuracy <- k.cross.fold.4(water.dataset.filtered, ml_naive_bayes, formula)
svc.4.fold.accuracy <- k.cross.fold.4(water.dataset.filtered, ml_linear_svc, formula)
d3.4.fold.accuracy <- k.cross.fold.4(water.dataset.filtered, ml_decision_tree_classifier, formula)
```

#### Tabelarni prikaz tačnosti različitih klasifikacionih modela u odnosu na metod testiranja modela
```{r Table view of the performance of different clustering models tested by different validation methods, echo=F}
knitr::kable(array(c("Bayes-ov model", "Mašina potpornih vektora", "Stablo odlučivanja",
                     bm.vs.accuracy, svcm.vs.accuracy, d3m.vs.accuracy,
                     bayes.model.4.fold.accuracy, svc.4.fold.accuracy, d3.4.fold.accuracy),
                   dim = c(3, 3)),
             col.names = c("Model", "Preciznost korišćenjem validacionog skupa", "Preciznost korišćenjem 4-strukog ukrštanja"),
             label = "Poređenje tačnosti različitih klasifikacionih modela u odnosu na načine validacije",
             align = "ccc",
             format = "markdown"
             )
```


## Klasterizacija podataka

### Prečišćenih podataka za proces klasterizacije
```{r Transformation of the dataset for the clustering process, eval=F, include=T}
dataset.for.clusterisation <- water.dataset.filtered %>%
  mutate(parameterWaterBodyCategory = switch(parameterWaterBodyCategory,
                                             CW="Coastal water body",
                                             GW="Ground water body",
                                             LW="Lake water body",
                                             MW="Marine waters",
                                             RW="River water body",
                                             TW="Transitional water body",
                                             TeW="Territorial waters")) %>%
  select(parameterWaterBodyCategory, resultNumberOfSamples, quantified)

dataset.for.clusterisation.summary <- dataset.for.clusterisation %>% 
  group_by(parameterWaterBodyCategory) %>% 
  summarize(count = n(), meanNumberOfSamples = mean(resultNumberOfSamples), stdev = sd(resultNumberOfSamples), quantified = avg(quantified)) %>% collect
```


### Prikaz prečišćenih podataka
```{r Displaying of transformed dataset for clusterisation, echo=F}
ggplot(dataset.for.clusterisation.summary,
       aes(quantified, meanNumberOfSamples, color = parameterWaterBodyCategory)) +
  geom_errorbar(aes(ymin = meanNumberOfSamples - stdev, ymax = meanNumberOfSamples + stdev), width=0.01) +
  theme(legend.position="right") +
  labs(y="mean(result number of samples)", x="quantified", color="Water body category")

```

### Metod k-means
```{r Settup of K-means clusterisation method, eval=F, include=T}
formula.clusterisation <- parameterWaterBodyCategory ~ resultNumberOfSamples + quantified

model.5   <- ml_kmeans(dataset.for.clusterisation, formula.clusterisation, seed = 1, k = 5)
model.10  <- ml_kmeans(dataset.for.clusterisation, formula.clusterisation, seed = 1, k = 10)
model.15  <- ml_kmeans(dataset.for.clusterisation, formula.clusterisation, seed = 1, k = 15)
model.20  <- ml_kmeans(dataset.for.clusterisation, formula.clusterisation, seed = 1, k = 20)
```

## Prikaz centroida klastera u odnosu na broj klastera K
```{r Graphing the centroids of different clusterisation models, echo=F}
cp1 <- model.5$centers %>%
  ggplot(aes(quantified, resultNumberOfSamples)) +
  geom_point() +
  labs(x="quantified", y="resultNumberOfSamples", title = "5-means") +
  theme_light()

cp2 <- model.10$centers %>%
  ggplot(aes(quantified, resultNumberOfSamples)) +
  geom_point() +
  labs(x="quantified", y="resultNumberOfSamples", title = "10-means") +
  theme_light()

cp3 <- model.15$centers %>%
  ggplot(aes(quantified, resultNumberOfSamples)) +
  geom_point() +
  labs(x="quantified", y="resultNumberOfSamples", title = "15-means") +
  theme_light()

cp4 <-  model.20$centers %>%
  ggplot(aes(quantified, resultNumberOfSamples)) +
  geom_point() +
  labs(x="quantified", y="resultNumberOfSamples", title = "20-means") +
  theme_light()

plot_grid(cp1, cp2, cp3, cp4, nrow=2, ncol=2)

```


## Zatvaranje spark konekcije
```{r Closing spark context, eval=F, include=T}
spark_disconnect(sc)
```
